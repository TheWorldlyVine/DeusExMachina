name: Main CI/CD Pipeline

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]
  workflow_dispatch:
    inputs:
      deploy_frontend:
        description: 'Deploy frontend applications'
        required: false
        default: true
        type: boolean
      deploy_backend:
        description: 'Deploy backend functions'
        required: false
        default: false
        type: boolean
      deploy_infrastructure:
        description: 'Deploy infrastructure'
        required: false
        default: false
        type: boolean

env:
  NODE_VERSION: '20'
  JAVA_VERSION: '21'
  PNPM_VERSION: '8'
  TERRAFORM_VERSION: '1.6.0'

jobs:
  # Detect changes
  changes:
    runs-on: ubuntu-latest
    outputs:
      backend: ${{ steps.filter.outputs.backend || (github.event_name == 'workflow_dispatch' && github.event.inputs.deploy_backend == 'true') }}
      frontend: ${{ steps.filter.outputs.frontend || (github.event_name == 'workflow_dispatch' && github.event.inputs.deploy_frontend == 'true') }}
      infrastructure: ${{ steps.filter.outputs.infrastructure || (github.event_name == 'workflow_dispatch' && github.event.inputs.deploy_infrastructure == 'true') }}
    steps:
      - uses: actions/checkout@v4
      
      - uses: dorny/paths-filter@v2
        id: filter
        with:
          filters: |
            backend:
              - 'apps/backend/**'
              - 'packages/java-common/**'
              - 'build.gradle'
              - 'settings.gradle'
            frontend:
              - 'apps/frontend/**'
              - 'packages/ui-components/**'
              - 'packages/utils/**'
              - 'package.json'
              - 'pnpm-lock.yaml'
            infrastructure:
              - 'infrastructure/**'

  # Java Backend CI/CD
  backend:
    needs: [changes]
    if: always() && (needs.changes.outputs.backend == 'true' || (github.event_name == 'workflow_dispatch' && github.event.inputs.deploy_backend == 'true'))
    runs-on: ubuntu-latest
    strategy:
      matrix:
        function: [auth-function, api-function, processor-function, email-processor-function, novel-ai-service, novel-memory-service, novel-document-service]
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up JDK ${{ env.JAVA_VERSION }}
        uses: actions/setup-java@v4
        with:
          java-version: ${{ env.JAVA_VERSION }}
          distribution: 'temurin'
          cache: 'gradle'
      
      - name: Grant execute permission for gradlew
        run: chmod +x apps/backend/gradlew
      
      - name: Run static analysis
        working-directory: apps/backend
        run: |
          ./gradlew spotbugsMain || true
          ./gradlew build -x test
      
      - name: Run tests
        working-directory: apps/backend
        run: ./gradlew :${{ matrix.function }}:test || true
      
      - name: Build function
        working-directory: apps/backend
        run: ./gradlew :${{ matrix.function }}:build
      
      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results-${{ matrix.function }}
          path: apps/backend/${{ matrix.function }}/build/test-results/
      
      - name: Authenticate to Google Cloud
        if: github.ref == 'refs/heads/main'
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}
      
      - name: Set function entry point
        id: entry_point
        run: |
          if [ "${{ matrix.function }}" = "auth-function" ]; then
            echo "entry_point=com.deusexmachina.functions.AuthFunction" >> $GITHUB_OUTPUT
          elif [ "${{ matrix.function }}" = "api-function" ]; then
            echo "entry_point=com.deusexmachina.functions.ApiFunction" >> $GITHUB_OUTPUT
          elif [ "${{ matrix.function }}" = "processor-function" ]; then
            echo "entry_point=com.deusexmachina.functions.ProcessorFunction" >> $GITHUB_OUTPUT
          elif [ "${{ matrix.function }}" = "email-processor-function" ]; then
            echo "entry_point=com.deusexmachina.email.processor.EmailProcessorFunction" >> $GITHUB_OUTPUT
          elif [ "${{ matrix.function }}" = "novel-ai-service" ]; then
            echo "entry_point=com.deusexmachina.novel.ai.NovelAIFunction" >> $GITHUB_OUTPUT
          elif [ "${{ matrix.function }}" = "novel-memory-service" ]; then
            echo "entry_point=com.deusexmachina.novel.memory.NovelMemoryFunction" >> $GITHUB_OUTPUT
          elif [ "${{ matrix.function }}" = "novel-document-service" ]; then
            echo "entry_point=com.deusexmachina.novel.document.NovelDocumentFunction" >> $GITHUB_OUTPUT
          fi
      
      - name: Deploy to GCP
        if: github.ref == 'refs/heads/main'
        run: |
          if [ "${{ matrix.function }}" = "email-processor-function" ]; then
            # Deploy email processor with Pub/Sub trigger
            gcloud functions deploy ${{ matrix.function }} \
              --gen2 \
              --runtime=java21 \
              --region=us-central1 \
              --source=apps/backend/${{ matrix.function }} \
              --entry-point=${{ steps.entry_point.outputs.entry_point }} \
              --trigger-topic=deus-ex-machina-email-events \
              --memory=512Mi \
              --max-instances=50 \
              --timeout=300s \
              --service-account=email-processor@${{ secrets.GCP_PROJECT_ID }}.iam.gserviceaccount.com \
              --set-env-vars="SMTP_FROM_EMAIL=${{ secrets.SMTP_FROM_EMAIL }},SMTP_FROM_NAME=DeusExMachina,SMTP_USERNAME=${{ secrets.SMTP_USERNAME }},SMTP_PASSWORD=${{ secrets.SMTP_PASSWORD }}"
          else
            # Use the GitHub Action for HTTP-triggered functions
            echo "Using GitHub Action deployment for ${{ matrix.function }}"
          fi
      
      - name: Deploy HTTP Functions
        if: github.ref == 'refs/heads/main' && matrix.function != 'email-processor-function'
        uses: google-github-actions/deploy-cloud-functions@v3
        with:
          name: ${{ matrix.function }}
          runtime: java21
          source_dir: apps/backend/${{ matrix.function }}
          entry_point: ${{ steps.entry_point.outputs.entry_point }}
          region: us-central1
          memory: ${{ (matrix.function == 'api-function' || matrix.function == 'novel-ai-service') && '1Gi' || '512Mi' }}
          max_instance_count: ${{ matrix.function == 'api-function' && '200' || matrix.function == 'processor-function' && '50' || '100' }}
          service_timeout: ${{ matrix.function == 'processor-function' && '540' || '300' }}
          env_vars: |
            GCP_PROJECT_ID=${{ secrets.GCP_PROJECT_ID }}
            JWT_SECRET=${{ secrets.JWT_SECRET }}
            EMAIL_TOPIC_NAME=${{ secrets.EMAIL_TOPIC_NAME }}
            APP_BASE_URL=https://god-in-a-box.com

  # GraphQL Gateway CI/CD
  graphql-gateway:
    needs: [changes]
    if: always() && (needs.changes.outputs.backend == 'true' || (github.event_name == 'workflow_dispatch' && github.event.inputs.deploy_backend == 'true'))
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - uses: pnpm/action-setup@v2
        with:
          version: ${{ env.PNPM_VERSION }}
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'pnpm'
      
      - name: Install dependencies
        working-directory: apps/backend/novel-graphql-gateway
        run: pnpm install --frozen-lockfile
      
      - name: Run linting
        working-directory: apps/backend/novel-graphql-gateway
        run: pnpm run lint
      
      - name: Run type checking
        working-directory: apps/backend/novel-graphql-gateway
        run: pnpm run type-check
      
      - name: Run tests
        working-directory: apps/backend/novel-graphql-gateway
        env:
          JWT_SECRET: test-secret
        run: pnpm test
      
      - name: Build application
        working-directory: apps/backend/novel-graphql-gateway
        run: pnpm run build
      
      - name: Authenticate to Google Cloud
        if: github.ref == 'refs/heads/main'
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}
      
      - name: Set up Cloud SDK
        if: github.ref == 'refs/heads/main'
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ secrets.GCP_PROJECT_ID }}
      
      - name: Configure Docker auth
        if: github.ref == 'refs/heads/main'
        run: gcloud auth configure-docker
      
      - name: Create .gcloudignore file
        if: github.ref == 'refs/heads/main'
        run: |
          cd apps/backend/novel-graphql-gateway
          cat > .gcloudignore << 'EOF'
          node_modules/
          .git/
          .gitignore
          README.md
          .env
          .env.*
          coverage/
          .nyc_output/
          *.log
          EOF
      
      - name: Build and push Docker image
        if: github.ref == 'refs/heads/main'
        run: |
          # Build the Docker image
          docker build -t gcr.io/${{ secrets.GCP_PROJECT_ID }}/novel-graphql-gateway -f apps/backend/novel-graphql-gateway/Dockerfile .
          
          # Push to Container Registry (gcr.io auto-creates repositories)
          docker push gcr.io/${{ secrets.GCP_PROJECT_ID }}/novel-graphql-gateway
      
      - name: Deploy to Cloud Run
        if: github.ref == 'refs/heads/main'
        run: |
          gcloud run deploy novel-graphql-gateway \
            --image gcr.io/${{ secrets.GCP_PROJECT_ID }}/novel-graphql-gateway \
            --platform managed \
            --region us-central1 \
            --allow-unauthenticated \
            --set-env-vars='^@^NODE_ENV=production@JWT_SECRET=${{ secrets.JWT_SECRET }}@AUTH_SERVICE_URL=https://auth-function-xkv3zhqrha-uw.a.run.app@DOCUMENT_SERVICE_URL=https://novel-document-service-xkv3zhqrha-uw.a.run.app@MEMORY_SERVICE_URL=https://novel-memory-service-xkv3zhqrha-uw.a.run.app@AI_SERVICE_URL=https://novel-ai-service-xkv3zhqrha-uw.a.run.app@ALLOWED_ORIGINS=https://god-in-a-box.com,https://novel-creator.deusexmachina.app,https://deusexmachina.app,http://34.95.119.251,https://34.95.119.251,http://localhost:3000,http://localhost:5173' \
            --memory=512Mi \
            --cpu=1 \
            --timeout=60 \
            --concurrency=100 \
            --max-instances=10 \
            --project=${{ secrets.GCP_PROJECT_ID }}

  # Frontend CI/CD
  frontend:
    needs: [changes]
    if: always() && (needs.changes.outputs.frontend == 'true' || (github.event_name == 'workflow_dispatch' && github.event.inputs.deploy_frontend == 'true'))
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - uses: pnpm/action-setup@v2
        with:
          version: ${{ env.PNPM_VERSION }}
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'pnpm'
      
      - name: Install dependencies
        run: pnpm install --frozen-lockfile
      
      - name: Run linting
        run: pnpm run lint
      
      - name: Run type checking
        run: pnpm run type-check
      
      - name: Run tests
        run: pnpm run test
      
      - name: Build applications
        run: |
          # Set production environment variables for Vite builds
          export VITE_API_URL=https://auth-function-tbmcifixdq-uc.a.run.app
          export VITE_DOCUMENT_API_URL=https://novel-document-service-tbmcifixdq-uc.a.run.app
          export VITE_AI_API_URL=https://novel-ai-service-tbmcifixdq-uc.a.run.app
          export VITE_MEMORY_API_URL=https://novel-memory-service-tbmcifixdq-uc.a.run.app
          export VITE_GRAPHQL_URL=https://novel-graphql-gateway-xkv3zhqrha-uc.a.run.app/graphql
          
          pnpm run build
      
      - name: Upload coverage
        uses: codecov/codecov-action@v3
        with:
          files: ./coverage/lcov.info
          flags: frontend
      
      - name: Authenticate to Google Cloud
        if: github.ref == 'refs/heads/main'
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}
          project_id: ${{ secrets.GCP_PROJECT_ID }}
      
      - name: Set up Cloud SDK
        if: github.ref == 'refs/heads/main'
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ secrets.GCP_PROJECT_ID }}
      
      - name: Deploy to Static Hosting
        if: github.ref == 'refs/heads/main'
        run: |
          # Get bucket name from GitHub variables or construct it
          PROJECT_ID="${{ secrets.GCP_PROJECT_ID }}"
          BUCKET_NAME="${{ vars.STATIC_HOSTING_BUCKET }}"
          
          # Debug: Check if PROJECT_ID is being passed
          echo "Debug: Raw PROJECT_ID length: ${#PROJECT_ID}"
          echo "Debug: PROJECT_ID first char: ${PROJECT_ID:0:1}"
          echo "Debug: PROJECT_ID is empty: $([ -z "$PROJECT_ID" ] && echo "YES" || echo "NO")"
          
          # Check if PROJECT_ID is set
          if [ -z "$PROJECT_ID" ]; then
            echo "ERROR: GCP_PROJECT_ID secret is not set or is empty!"
            echo "Please check your repository secrets:"
            echo "1. Go to Settings â†’ Secrets and variables â†’ Actions"
            echo "2. Look for GCP_PROJECT_ID in the secrets list"
            echo "3. Click 'Update' and re-enter your GCP project ID"
            echo "4. Make sure there are no extra spaces or quotes"
            echo ""
            echo "The secret appears to be: '${PROJECT_ID}' (should not be empty)"
            exit 1
          fi
          
          # If BUCKET_NAME is not set, construct it from PROJECT_ID
          if [ -z "$BUCKET_NAME" ]; then
            # Convert underscores to hyphens for valid bucket names
            SAFE_PROJECT_ID=$(echo "${PROJECT_ID}" | tr '_' '-')
            # Simple bucket name: project_id-static
            BUCKET_NAME="${SAFE_PROJECT_ID}-static"
          fi
          
          echo "Project ID: ${PROJECT_ID}"
          echo "Project ID length: ${#PROJECT_ID}"
          echo "Deploying to bucket: gs://${BUCKET_NAME}/"
          
          # List all buckets in the project to debug
          echo ""
          echo "Listing all buckets in project:"
          gcloud storage buckets list --project=${PROJECT_ID} || echo "Failed to list buckets"
          
          # Check if bucket exists using gcloud
          if ! gcloud storage buckets describe gs://${BUCKET_NAME} --project=${PROJECT_ID} &>/dev/null; then
            echo ""
            echo "ERROR: Bucket gs://${BUCKET_NAME}/ does not exist!"
            echo ""
            echo "Checking for similar bucket names:"
            gcloud storage buckets list --project=${PROJECT_ID} | grep -i static || echo "No static buckets found"
            echo ""
            echo "Please ensure the Infrastructure workflow completed successfully."
            echo "The infrastructure should have created a bucket named: ${BUCKET_NAME}"
            exit 1
          fi
          
          # Deploy all frontend apps to Cloud Storage
          for app_dir in apps/frontend/*/; do
            app_name=$(basename "$app_dir")
            
            # Skip if not a directory or if dist folder doesn't exist
            if [ ! -d "$app_dir" ] || [ ! -d "${app_dir}dist" ]; then
              echo "Skipping $app_name (no dist folder found)"
              continue
            fi
            
            echo "Deploying $app_name to gs://${BUCKET_NAME}/${app_name}/"
            
            # Deploy app to its own subdirectory
            gsutil -m rsync -r -d "${app_dir}dist/" "gs://${BUCKET_NAME}/${app_name}/"
            
            # For SPAs, create index.html copies for common routes to handle client-side routing
            if [ -f "${app_dir}dist/index.html" ]; then
              echo "Setting up SPA routing fallbacks for $app_name"
              
              # Copy index.html to 404.html for general fallback
              gsutil cp "gs://${BUCKET_NAME}/${app_name}/index.html" "gs://${BUCKET_NAME}/${app_name}/404.html"
              
              # Create common route directories with index.html for SPAs
              # This ensures refresh works on these routes
              for route in "login" "documents" "editor" "settings" "signup" "dashboard"; do
                echo "Creating fallback for /${app_name}/${route}"
                gsutil cp "gs://${BUCKET_NAME}/${app_name}/index.html" "gs://${BUCKET_NAME}/${app_name}/${route}/index.html"
              done
            fi
            
            # Set cache headers for different file types
            gsutil -m setmeta -h "Cache-Control:public, max-age=31536000" "gs://${BUCKET_NAME}/${app_name}/**/*.js" || true
            gsutil -m setmeta -h "Cache-Control:public, max-age=31536000" "gs://${BUCKET_NAME}/${app_name}/**/*.css" || true
            gsutil -m setmeta -h "Cache-Control:public, max-age=2592000" "gs://${BUCKET_NAME}/${app_name}/**/*.{png,jpg,jpeg,gif,svg,webp}" || true
            gsutil -m setmeta -h "Cache-Control:public, max-age=300" "gs://${BUCKET_NAME}/${app_name}/**/*.html" || true
            gsutil -m setmeta -h "Cache-Control:no-cache" "gs://${BUCKET_NAME}/${app_name}/index.html" || true
            gsutil -m setmeta -h "Cache-Control:no-cache" "gs://${BUCKET_NAME}/${app_name}/404.html" || true
          done
          
          # Deploy the landing page to root
          if [ -d "apps/frontend/landing-page/dist" ]; then
            echo "Deploying landing-page to root path"
            echo "Contents of dist folder:"
            ls -la apps/frontend/landing-page/dist/
            # Use rsync without -d flag to avoid deleting other apps
            # Only sync the landing page files, don't delete web-app/ and other subdirectories
            gsutil -m cp -r apps/frontend/landing-page/dist/* gs://${BUCKET_NAME}/
            gsutil -m setmeta -h "Cache-Control:no-cache" gs://${BUCKET_NAME}/index.html || true
            echo "Deployment complete. Verifying bucket contents:"
            gsutil ls -la gs://${BUCKET_NAME}/ | head -20
          else
            echo "ERROR: Landing page dist folder not found!"
            ls -la apps/frontend/landing-page/
          fi
      
      - name: Invalidate CDN Cache
        if: github.ref == 'refs/heads/main'
        run: |
          PROJECT_ID="${{ secrets.GCP_PROJECT_ID }}"
          URL_MAP_NAME="${{ vars.STATIC_URL_MAP_NAME }}"
          
          # If URL_MAP_NAME is not set, construct it from PROJECT_ID
          if [ -z "$URL_MAP_NAME" ]; then
            URL_MAP_NAME="deus-ex-machina-prod-static-url-map"
          fi
          
          echo "Invalidating CDN cache for URL map: ${URL_MAP_NAME}"
          gcloud compute url-maps invalidate-cdn-cache ${URL_MAP_NAME} --path "/*" --async || echo "CDN cache invalidation skipped (URL map may not exist)"
      
      # Vercel deployment removed - using GCS static hosting instead

  # Infrastructure CI/CD
  infrastructure:
    needs: changes
    if: always() && (needs.changes.outputs.infrastructure == 'true' || (github.event_name == 'workflow_dispatch' && github.event.inputs.deploy_infrastructure == 'true'))
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}
      
      - name: Terraform Format Check
        run: terraform fmt -check -recursive infrastructure/
      
      - name: Run tfsec
        uses: aquasecurity/tfsec-action@v1.0.3
        with:
          working_directory: infrastructure/
          soft_fail: true
      
      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}
      
      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ secrets.GCP_PROJECT_ID }}
      
      - name: Setup Terraform Backend
        run: |
          PROJECT_ID=${{ secrets.GCP_PROJECT_ID }}
          BUCKET_NAME="${PROJECT_ID}-terraform-state"
          SERVICE_ACCOUNT="terraform-sa@${PROJECT_ID}.iam.gserviceaccount.com"
          
          # Use gcloud storage instead of gsutil for better auth handling
          # Create state bucket if it doesn't exist
          if ! gcloud storage buckets describe gs://${BUCKET_NAME} &> /dev/null; then
            echo "Creating Terraform state bucket: gs://${BUCKET_NAME}"
            gcloud storage buckets create gs://${BUCKET_NAME} \
              --project=${PROJECT_ID} \
              --default-storage-class=STANDARD \
              --location=us-central1 \
              --uniform-bucket-level-access
            
            # Enable versioning
            gcloud storage buckets update gs://${BUCKET_NAME} --versioning
          else
            echo "Terraform state bucket already exists: gs://${BUCKET_NAME}"
          fi
          
          # Grant the service account permissions to the bucket
          echo "Granting storage permissions to service account..."
          gcloud storage buckets add-iam-policy-binding gs://${BUCKET_NAME} \
            --member="serviceAccount:${SERVICE_ACCOUNT}" \
            --role="roles/storage.objectAdmin"
      
      - name: Terraform Init
        run: |
          cd infrastructure/environments/${{ github.event_name == 'pull_request' && 'staging' || 'prod' }}
          terraform init \
            -backend-config="bucket=${{ secrets.GCP_PROJECT_ID }}-terraform-state" \
            -backend-config="prefix=terraform/state"
      
      - name: Terraform Plan
        run: |
          cd infrastructure/environments/${{ github.event_name == 'pull_request' && 'staging' || 'prod' }}
          terraform plan -var="project_id=${{ secrets.GCP_PROJECT_ID }}" -out=tfplan
      
      - name: Upload Terraform Plan
        uses: actions/upload-artifact@v4
        with:
          name: terraform-plan
          path: infrastructure/environments/*/tfplan
      
      - name: Terraform Apply
        if: github.ref == 'refs/heads/main'
        run: |
          cd infrastructure/environments/prod
          # Use smart apply script that only ignores "already exists" errors
          ../../../scripts/terraform-apply-smart.sh
      
      - name: Export Outputs
        if: github.ref == 'refs/heads/main'
        id: outputs
        run: |
          cd infrastructure/environments/prod
          # Export key outputs as GitHub variables
          echo "STATIC_HOSTING_BUCKET=$(terraform output -raw static_hosting_bucket)" >> $GITHUB_ENV
          echo "STATIC_HOSTING_IP=$(terraform output -raw static_hosting_ip)" >> $GITHUB_ENV
          echo "STATIC_HOSTING_URL=$(terraform output -raw static_hosting_url)" >> $GITHUB_ENV
      
      - name: Post Deployment Summary
        if: github.ref == 'refs/heads/main'
        run: |
          cd infrastructure/environments/prod
          echo "## ðŸš€ Infrastructure Deployment Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Outputs:" >> $GITHUB_STEP_SUMMARY
          echo "- **Static Hosting URL**: $(terraform output -raw static_hosting_url)" >> $GITHUB_STEP_SUMMARY
          echo "- **Bucket Name**: $(terraform output -raw static_hosting_bucket)" >> $GITHUB_STEP_SUMMARY
          echo "- **Static IP**: $(terraform output -raw static_hosting_ip)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Next Steps:" >> $GITHUB_STEP_SUMMARY
          echo "1. The frontend will be automatically deployed on the next push" >> $GITHUB_STEP_SUMMARY
          echo "2. Update DNS records if using custom domain" >> $GITHUB_STEP_SUMMARY
  
  # Deploy Firestore indexes after infrastructure
  firestore-indexes:
    needs: [infrastructure]
    if: github.ref == 'refs/heads/main' && needs.infrastructure.result == 'success'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}
          project_id: ${{ secrets.GCP_PROJECT_ID }}
      
      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ secrets.GCP_PROJECT_ID }}
      
      - name: Deploy Firestore Indexes
        run: |
          echo "Deploying Firestore composite indexes..."
          
          # Deploy novel_documents indexes
          gcloud firestore indexes create \
            --collection-group=novel_documents \
            --field-config field-path=authorId,order=ascending \
            --field-config field-path=active,order=ascending \
            --field-config field-path=updatedAt,order=descending \
            --project=${{ secrets.GCP_PROJECT_ID }} || echo "Index may already exist"
          
          # Deploy novel_chapters indexes
          gcloud firestore indexes create \
            --collection-group=novel_chapters \
            --field-config field-path=documentId,order=ascending \
            --field-config field-path=active,order=ascending \
            --field-config field-path=chapterNumber,order=ascending \
            --project=${{ secrets.GCP_PROJECT_ID }} || echo "Index may already exist"
          
          # Deploy novel_scenes indexes
          gcloud firestore indexes create \
            --collection-group=novel_scenes \
            --field-config field-path=chapterId,order=ascending \
            --field-config field-path=active,order=ascending \
            --field-config field-path=sceneNumber,order=ascending \
            --project=${{ secrets.GCP_PROJECT_ID }} || echo "Index may already exist"
          
          echo "âœ… Firestore indexes deployed successfully!"